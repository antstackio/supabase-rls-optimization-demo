-- Initial Configuration Settings
SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = ON;
SELECT pg_catalog.set_config('search_path', '', FALSE);
SET check_function_bodies = FALSE;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = OFF;

-- Extensions
CREATE EXTENSION IF NOT EXISTS "pgsodium" WITH SCHEMA "pgsodium";
COMMENT ON SCHEMA "public" IS 'standard public schema';
CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";
CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "pgjwt" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";
CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";

-- Custom Types
CREATE TYPE "public"."project_status" AS ENUM ('active', 'completed');
ALTER TYPE "public"."project_status" OWNER TO "postgres";

CREATE TYPE "public"."task_priority" AS ENUM ('low', 'medium', 'high');
ALTER TYPE "public"."task_priority" OWNER TO "postgres";

CREATE TYPE "public"."task_status" AS ENUM ('todo', 'in_progress', 'done');
ALTER TYPE "public"."task_status" OWNER TO "postgres";

CREATE TYPE "public"."user_type" AS ENUM ('ADMIN', 'ORGANIZATION', 'USER');
ALTER TYPE "public"."user_type" OWNER TO "postgres";

-- Table Definitions
CREATE TABLE IF NOT EXISTS "public"."projects" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    "name" text NOT NULL,
    "description" text,
    "status" public.project_status DEFAULT 'active',
    "created_by" bigint,
    "tenant_ids" bigint[] NOT NULL,
    "created_at" timestamp WITH TIME ZONE DEFAULT now(),
    CONSTRAINT "projects_pkey" PRIMARY KEY ("id")
);
ALTER TABLE "public"."projects" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."tasks" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    "project_id" bigint,
    "title" text NOT NULL,
    "description" text,
    "status" public.task_status DEFAULT 'todo',
    "priority" public.task_priority DEFAULT 'medium',
    "assigned_to" bigint,
    "estimated_hours" numeric(5,2),
    "created_at" timestamp WITH TIME ZONE DEFAULT now(),
    "completed_at" timestamp WITH TIME ZONE,
    CONSTRAINT "tasks_pkey" PRIMARY KEY ("id")
);
ALTER TABLE "public"."tasks" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."tenants" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    "name" text NOT NULL,
    "created_at" timestamp WITH TIME ZONE DEFAULT now(),
    CONSTRAINT "tenants_pkey" PRIMARY KEY ("id")
);
ALTER TABLE "public"."tenants" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."users" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    "full_name" text NOT NULL,
    "email" text NOT NULL,
    "tenant_id" bigint NOT NULL,
    "user_type" public.user_type DEFAULT 'USER' NOT NULL,
    "created_at" timestamp WITH TIME ZONE DEFAULT now(),
    CONSTRAINT "users_pkey" PRIMARY KEY ("id"),
    CONSTRAINT "users_email_key" UNIQUE ("email")
);
ALTER TABLE "public"."users" OWNER TO "postgres";

-- Indexes
CREATE INDEX "idx_projects_created_by" ON public.projects USING btree (created_by);
CREATE INDEX "idx_projects_tenant_ids" ON public.projects USING gin (tenant_ids);
CREATE INDEX "idx_tasks_assigned_to" ON public.tasks USING btree (assigned_to);
CREATE INDEX "idx_tasks_project_id" ON public.tasks USING btree (project_id);
CREATE INDEX "idx_tasks_status" ON public.tasks USING btree (status);
CREATE INDEX "idx_users_email" ON public.users USING btree (email);
CREATE INDEX "idx_users_tenant_id" ON public.users USING btree (tenant_id);

-- Foreign Key Constraints
ALTER TABLE ONLY public.projects
    ADD CONSTRAINT "projects_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id);

ALTER TABLE ONLY public.tasks
    ADD CONSTRAINT "tasks_assigned_to_fkey" FOREIGN KEY (assigned_to) REFERENCES public.users(id),
    ADD CONSTRAINT "tasks_project_id_fkey" FOREIGN KEY (project_id) REFERENCES public.projects(id);

ALTER TABLE ONLY public.users
    ADD CONSTRAINT "users_tenant_id_fkey" FOREIGN KEY (tenant_id) REFERENCES public.tenants(id);

-- Functions
CREATE OR REPLACE FUNCTION public.get_jwt_claim(claim_key text)
RETURNS text LANGUAGE plpgsql IMMUTABLE AS $$
BEGIN
    RETURN (current_setting('request.jwt.claims', true)::json ->> claim_key);
END;
$$;
ALTER FUNCTION "public"."get_jwt_claim"("claim_key" text) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION public.generate_array_test1_data(
    num_projects integer DEFAULT 2000,
    num_tasks integer DEFAULT 100000,
    batch_size integer DEFAULT 500
) RETURNS void LANGUAGE plpgsql AS $$
DECLARE 
    project RECORD;
BEGIN
    PERFORM set_config('statement_timeout', '10min', false);
    
    FOR batch IN 0..(num_projects / batch_size) LOOP
        INSERT INTO projects (name, description, status, created_by, tenant_ids, created_at)
        SELECT 
            'Project ' || (batch * batch_size + i),
            'Description for project ' || (batch * batch_size + i),
            CASE (random() * 1)::integer 
                WHEN 0 THEN 'active'::project_status 
                ELSE 'completed'::project_status 
            END,
            (SELECT id FROM users ORDER BY random() LIMIT 1),
            ARRAY(
                SELECT id FROM (
                    SELECT id FROM tenants ORDER BY random() 
                    LIMIT (floor(random() * (5 - 1)) + 1)::int
                ) AS t
            ),
            NOW() - (random() * interval '365 days')
        FROM generate_series(1, LEAST(batch_size, num_projects - batch * batch_size)) AS i
        WHERE (batch * batch_size + i) <= num_projects;
    END LOOP;

    DECLARE 
        tasks_per_project int := (num_tasks / num_projects)::int;
        task_batch_size int := LEAST(batch_size, tasks_per_project);
    BEGIN
        FOR project IN SELECT id, tenant_ids FROM projects LOOP
            FOR batch IN 0..(tasks_per_project / task_batch_size) LOOP
                INSERT INTO tasks (
                    project_id, title, description, status, priority, 
                    assigned_to, estimated_hours, created_at, completed_at
                )
                SELECT 
                    project.id,
                    'Task ' || (batch * task_batch_size + i),
                    'Description for task ' || (batch * task_batch_size + i),
                    CASE (random() * 2)::integer 
                        WHEN 0 THEN 'todo'::task_status 
                        WHEN 1 THEN 'in_progress'::task_status 
                        ELSE 'done'::task_status 
                    END,
                    CASE (random() * 2)::integer 
                        WHEN 0 THEN 'low'::task_priority 
                        WHEN 1 THEN 'medium'::task_priority 
                        ELSE 'high'::task_priority 
                    END,
                    (SELECT u.id FROM users u WHERE u.tenant_id = ANY(project.tenant_ids) ORDER BY random() LIMIT 1),
                    (random() * 40 + 1)::numeric(5,2),
                    NOW() - (random() * interval '30 days'),
                    CASE WHEN random() > 0.5 THEN NOW() - (random() * interval '30 days') ELSE NULL END
                FROM generate_series(
                    1, 
                    LEAST(task_batch_size, tasks_per_project - batch * task_batch_size)
                ) AS i
                WHERE (batch * task_batch_size + i) <= tasks_per_project;
            END LOOP;
        END LOOP;
    END;
END;
$$;
ALTER FUNCTION "public"."generate_array_test1_data"(integer, integer, integer) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION public.get_project_analytics()
RETURNS TABLE(
    project_id bigint,
    project_name text,
    total_tasks bigint,
    completed_tasks bigint,
    avg_estimated_hours numeric,
    total_assignees bigint,
    avg_completion_time_hours numeric,
    user_stats jsonb
) LANGUAGE plpgsql AS $$
BEGIN
    RETURN QUERY 
    SELECT 
        p.id AS project_id,
        p.name AS project_name,
        COUNT(DISTINCT t.id) AS total_tasks,
        COUNT(DISTINCT t.id) FILTER (WHERE t.status = 'done') AS completed_tasks,
        ROUND(AVG(t.estimated_hours), 2) AS avg_estimated_hours,
        COUNT(DISTINCT t.assigned_to) AS total_assignees,
        ROUND(AVG(EXTRACT(EPOCH FROM (t.completed_at - t.created_at))/3600)::numeric, 2) AS avg_completion_time_hours,
        jsonb_agg(DISTINCT jsonb_build_object(
            'user_id', u.id,
            'name', u.full_name,
            'tasks_count', COUNT(t.id)
        )) FILTER (WHERE u.id IS NOT NULL) AS user_stats
    FROM projects p
    LEFT JOIN tasks t ON t.project_id = p.id
    LEFT JOIN users u ON t.assigned_to = u.id
    GROUP BY p.id, p.name
    ORDER BY total_tasks DESC;
END;
$$;
ALTER FUNCTION "public"."get_project_analytics"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION public.get_projects_analytics(project_ids bigint[] DEFAULT NULL)
RETURNS TABLE (
    project_id bigint,
    project_name text,
    tenant_ids bigint[],
    total_tasks bigint,
    completed_tasks bigint,
    avg_estimated_hours numeric,
    total_assignees bigint,
    avg_completion_time_hours numeric
) LANGUAGE plpgsql AS $$
BEGIN
    PERFORM set_config('statement_timeout', '600000', true);
    
    RETURN QUERY 
    WITH user_task_counts AS (
        SELECT t.assigned_to, COUNT(t.id) AS tasks_count 
        FROM tasks t 
        GROUP BY t.assigned_to
    )
    SELECT 
        p.id AS project_id,
        p.name AS project_name,
        p.tenant_ids AS tenant_ids,
        COUNT(DISTINCT t.id) AS total_tasks,
        COUNT(DISTINCT t.id) FILTER (WHERE t.status = 'done') AS completed_tasks,
        ROUND(AVG(t.estimated_hours), 2) AS avg_estimated_hours,
        COUNT(DISTINCT t.assigned_to) AS total_assignees,
        ROUND(AVG(EXTRACT(EPOCH FROM (t.completed_at - t.created_at))/3600)::numeric, 2) AS avg_completion_time_hours
    FROM projects p
    LEFT JOIN tasks t ON t.project_id = p.id
    LEFT JOIN users u ON t.assigned_to = u.id
    WHERE (project_ids IS NULL OR p.id = ANY(project_ids))
    GROUP BY p.id, p.name
    ORDER BY total_tasks DESC;
END;
$$;
ALTER FUNCTION "public"."get_projects_analytics"(bigint[]) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION public.get_query_execution_time(query text)
RETURNS numeric LANGUAGE plpgsql AS $$
DECLARE
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
BEGIN
    PERFORM set_config('statement_timeout', '600000', true);
    start_time := clock_timestamp();
    EXECUTE query;
    end_time := clock_timestamp();
    RETURN EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;
END;
$$;
ALTER FUNCTION "public"."get_query_execution_time"(text) OWNER TO "postgres";

-- Row Level Security Policies
CREATE POLICY "project_access_policy" ON public.projects AS PERMISSIVE
FOR ALL
TO authenticated
    USING (CASE 
        WHEN public.get_jwt_claim('type') = 'ADMIN' THEN TRUE
        WHEN public.get_jwt_claim('type') = ANY (ARRAY['ORGANIZATION', 'USER']) 
            THEN ((current_setting('request.jwt.claims', TRUE))::json ->> 'tenant_ids')::bigint[] && tenant_ids
        ELSE FALSE
    END)
    WITH CHECK (CASE 
        WHEN public.get_jwt_claim('type') = 'ADMIN' THEN TRUE
        WHEN public.get_jwt_claim('type') = ANY (ARRAY['ORGANIZATION', 'USER'])
            THEN ((current_setting('request.jwt.claims', TRUE))::json ->> 'tenant_ids')::bigint[] && tenant_ids
        ELSE FALSE
    END);

CREATE POLICY "task_access_policy" ON public.tasks AS PERMISSIVE
FOR ALL
TO authenticated
    USING (CASE 
        WHEN public.get_jwt_claim('type') = 'ADMIN' THEN TRUE
        WHEN public.get_jwt_claim('type') = ANY (ARRAY['ORGANIZATION', 'USER'])
            THEN project_id IN (SELECT id FROM public.projects)
        ELSE FALSE
    END)
    WITH CHECK (CASE 
        WHEN public.get_jwt_claim('type') = 'ADMIN' THEN TRUE
        WHEN public.get_jwt_claim('type') = ANY (ARRAY['ORGANIZATION', 'USER'])
            THEN project_id IN (SELECT id FROM public.projects)
        ELSE FALSE
    END);

CREATE POLICY "tenant_access_policy" ON public.tenants AS PERMISSIVE
FOR ALL
TO authenticated
    USING (CASE 
        WHEN public.get_jwt_claim('type') = 'ADMIN' THEN TRUE
        WHEN public.get_jwt_claim('type') = ANY (ARRAY['ORGANIZATION', 'USER'])
            THEN id = ANY(((current_setting('request.jwt.claims', TRUE))::json ->> 'tenant_ids')::bigint[])
        ELSE FALSE
    END)
    WITH CHECK (CASE 
        WHEN public.get_jwt_claim('type') = 'ADMIN' THEN TRUE
        WHEN public.get_jwt_claim('type') = 'ORGANIZATION'
            THEN id = ANY(((current_setting('request.jwt.claims', TRUE))::json ->> 'tenant_ids')::bigint[])
        ELSE FALSE
    END);

CREATE POLICY "user_access_policy" ON "public"."users"
AS PERMISSIVE
FOR ALL
TO authenticated
USING (
   CASE 
        WHEN public.get_jwt_claim('type') = 'ADMIN' THEN TRUE
        WHEN public.get_jwt_claim('type') = ANY (ARRAY['ORGANIZATION', 'USER'])
            THEN tenant_id = ANY(((current_setting('request.jwt.claims', TRUE))::json ->> 'tenant_ids')::bigint[])
        ELSE FALSE
    END)
    WITH CHECK (CASE 
        WHEN public.get_jwt_claim('type') = 'ADMIN' THEN TRUE
        ELSE FALSE
    END);

ALTER TABLE public.projects ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tenants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- Grants and Permissions
GRANT USAGE ON SCHEMA public TO postgres;
GRANT USAGE ON SCHEMA public TO anon;
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT USAGE ON SCHEMA public TO service_role;

-- Function Grants
GRANT ALL ON FUNCTION public.get_jwt_claim(text) TO anon;
GRANT ALL ON FUNCTION public.get_jwt_claim(text) TO authenticated;
GRANT ALL ON FUNCTION public.get_jwt_claim(text) TO service_role;

GRANT ALL ON FUNCTION public.generate_array_test1_data(integer, integer, integer) TO anon;
GRANT ALL ON FUNCTION public.generate_array_test1_data(integer, integer, integer) TO authenticated;
GRANT ALL ON FUNCTION public.generate_array_test1_data(integer, integer, integer) TO service_role;

GRANT ALL ON FUNCTION public.get_project_analytics() TO anon;
GRANT ALL ON FUNCTION public.get_project_analytics() TO authenticated;
GRANT ALL ON FUNCTION public.get_project_analytics() TO service_role;

GRANT ALL ON FUNCTION public.get_projects_analytics(bigint[]) TO anon;
GRANT ALL ON FUNCTION public.get_projects_analytics(bigint[]) TO authenticated;
GRANT ALL ON FUNCTION public.get_projects_analytics(bigint[]) TO service_role;

GRANT ALL ON FUNCTION public.get_query_execution_time(text) TO anon;
GRANT ALL ON FUNCTION public.get_query_execution_time(text) TO authenticated;
GRANT ALL ON FUNCTION public.get_query_execution_time(text) TO service_role;

-- Table Grants
GRANT ALL ON TABLE public.projects TO anon;
GRANT ALL ON TABLE public.projects TO authenticated;
GRANT ALL ON TABLE public.projects TO service_role;

GRANT ALL ON TABLE public.tasks TO anon;
GRANT ALL ON TABLE public.tasks TO authenticated;
GRANT ALL ON TABLE public.tasks TO service_role;

GRANT ALL ON TABLE public.tenants TO anon;
GRANT ALL ON TABLE public.tenants TO authenticated;
GRANT ALL ON TABLE public.tenants TO service_role;

GRANT ALL ON TABLE public.users TO anon;
GRANT ALL ON TABLE public.users TO authenticated;
GRANT ALL ON TABLE public.users TO service_role;

-- Sequence Grants
GRANT ALL ON SEQUENCE public.projects_id_seq TO anon;
GRANT ALL ON SEQUENCE public.projects_id_seq TO authenticated;
GRANT ALL ON SEQUENCE public.projects_id_seq TO service_role;

GRANT ALL ON SEQUENCE public.tasks_id_seq TO anon;
GRANT ALL ON SEQUENCE public.tasks_id_seq TO authenticated;
GRANT ALL ON SEQUENCE public.tasks_id_seq TO service_role;

GRANT ALL ON SEQUENCE public.tenants_id_seq TO anon;
GRANT ALL ON SEQUENCE public.tenants_id_seq TO authenticated;
GRANT ALL ON SEQUENCE public.tenants_id_seq TO service_role;

GRANT ALL ON SEQUENCE public.users_id_seq TO anon;
GRANT ALL ON SEQUENCE public.users_id_seq TO authenticated;
GRANT ALL ON SEQUENCE public.users_id_seq TO service_role;

-- Default Privileges
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public 
    GRANT ALL ON SEQUENCES TO postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public 
    GRANT ALL ON FUNCTIONS TO postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public 
    GRANT ALL ON TABLES TO postgres, anon, authenticated, service_role;

-- Publication
ALTER PUBLICATION supabase_realtime OWNER TO postgres;

RESET ALL;